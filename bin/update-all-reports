#!/usr/bin/env perl

# update-all-reports:
# Generate the data for the /reports page
#
# Copyright (c) 2011 UK Citizens Online Democracy. All rights reserved.
# Email: matthew@mysociety.org. WWW: http://www.mysociety.org

use strict;
use warnings;
require 5.8.0;

BEGIN {
    use File::Basename qw(dirname);
    use File::Spec;
    my $d = dirname(File::Spec->rel2abs($0));
    require "$d/../setenv.pl";
}

use FixMyStreet::App;
use File::Path ();
use File::Slurp;
use JSON;
use List::MoreUtils qw(zip);

my $fourweeks = 4*7*24*60*60;

my $cobrand_name = do {
    my $base_url = FixMyStreet->config('BASE_URL');
    if ( $base_url =~ /zurich|zueri/ ) {
        'zurich';
    }
    elsif ( $base_url =~ /emptyhomes/ ) {
        'emptyhomes';
    }
    elsif ( $base_url =~ /smidsy|collideosco/ ) {
        'smidsy';
    }
    else {
        'default';
    }
};

my $cobrand = FixMyStreet::Cobrand->get_class_for_moniker($cobrand_name)->new();

my $age_column = $cobrand->age_column;
# Age problems from when they're confirmed, except on Zurich
# where they appear as soon as they're created.

my @extra_cols = $cobrand->can('extra_stats_cols') ? $cobrand->extra_stats_cols : ();

my $problems = FixMyStreet::App->model("DB::Problem")->search(
    {
        state => [ FixMyStreet::DB::Result::Problem->visible_states() ],
    },
    {
        columns => [
            'id', 'bodies_str', 'state', 'areas', @extra_cols,
            { duration => { extract => "epoch from current_timestamp-lastupdate" } },
            { age      => { extract => "epoch from current_timestamp-$age_column"  } },
        ]
    }
);
$problems = $problems->cursor; # Raw DB cursor for speed

my ( %fixed, %open );
my %stats = (
    fixed => \%fixed,
    open  => \%open,
);

my @cols = ( 'id', 'bodies_str', 'state', 'areas', @extra_cols, 'duration', 'age' );
while ( my @problem = $problems->next ) {
    my %problem = zip @cols, @problem;
    my @bodies;
    if ( !$problem{bodies_str} ) {
        # Problem was not sent to any bodies, add to all areas
        @bodies = grep { $_ } split( /,/, $problem{areas} );
        $problem{bodies} = 0;
    } else {
        # Add to bodies it was sent to
        (my $bodies = $problem{bodies_str}) =~ s/\|.*$//;
        @bodies = split( /,/, $bodies );
        $problem{bodies} = scalar @bodies;
    }
    foreach my $body ( @bodies ) {
        my $duration_str = ( $problem{duration} > 2 * $fourweeks ) ? 'old' : 'new';

        if (FixMyStreet::DB::Result::Problem->fixed_states()->{$problem{state}} || FixMyStreet::DB::Result::Problem->closed_states()->{$problem{state}}) {
            # Fixed problems are either old or new
            $fixed{$body}{$duration_str}++;
        } else {
            # Open problems are either unknown, older, or new
            my $type = $cobrand->stats_open_problem_type(\%problem);
            $open{$body}{$type}++;
        }
    }
}

$cobrand->munge_stats(\%stats) if $cobrand->can('munge_stats');

my $body = JSON->new->utf8(1)->encode( \%stats );

File::Path::mkpath( FixMyStreet->path_to( '../data/' )->stringify );
File::Slurp::write_file( FixMyStreet->path_to( '../data/all-reports.json' )->stringify, \$body );

